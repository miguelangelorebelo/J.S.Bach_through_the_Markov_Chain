---
title: "J.S. Bach through the Markov Chain"
author: "Miguel Ângelo Rebelo"
date: "17/12/2020"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(here)
source(here::here("rmd_config.R"))
```

# 1. Introduction

## 1.1 Markov Chains

Markov Chains (MC) are a class of stochastic processes, highly effective at modelling categorical data sequences. Notable applications can be found in linguistics, information theory, medicine, economics, sociology, etc.

A MC is defined by a stochastic matrix known as transition matrix (TM), which is a square matrix satisfying the equation:

$P_{ij}\in[0,1]∀ij$

$\sum_{i}P_{ij}=1$

A MC is a stochastic process with a discrete set of states, {s1, s2, ..., sk}. The chain starts in a generic state at time zero (t~0~) and moves from a state to another by steps. P~ij~ is the probability that a chain currently in state s~i~ moves to state s~j~ at the next step, and this does not depend upon the precious state in the chain. P~ij~ is defined by a transition matrix (TM), which has the transition probabilities. 

The n~th~ power of P is a matrix whose entries represent the probabilities that a MC in state s~i~ at time *t* will be in state s~j~ at time *t* + *n*. 

Main properties of MC:

- A state s~i~ is reachable from state s~j~ if $∃n\to P\binom{n}{ij}>0$. If the inverse is also true, then s~i~and s~j~ *communicate*. 

- There always exists a unique decomposition of the state space into a sequence of disjoint subsets in which all the states within each subset communicate (*communicating class*). 

- If it is impossible to leave a state s~j~, it is said to be absorbing, meaning P~jj~ = 1. A chain with at least one *absorbing state* which can be reached is an *absorbing MC*, and the other states are defined as *transient states*. States that can be visited more than once are known as *recurrent states*.

- If a MC contains r ≥ 1 *absorbing* states, it is possible to re-arrange their order by separating *t* *transient* and *r* *absorbing* states. Such re-arranged matrix is said to be in canonical form, where its composition can be represented by sub-matrices:

$[\begin{array}(Q_{tt}&R_{tr}\\0_{rt}&I_{rr}\end{array}]$

Such matrices are:

1. Q, a sub-matrix containing the transition probabilities across *transient* states; 

2. R, a non-zero *t*-by-*r* matrix containing transition probabilities from non-absorbing to absorbing states; 

3. 0, an *r*-by-*t* zero matrix; 

4. I, an *r*-by-*r* identity matrix. 

- These matrices can be used to compute structural properties of the MC. Since $lim_{\to∞}Q_n=0$, in every absorbing matrix the probability to eventually be absorbed is 1, regardless of the initial state.

- In the fundamental matrix N, the generic n~ij~ entry expresses the expected number of times the process will transit in state s~j~, given that it started in state s~i~. 

$N=(I-Q)^{-1}=I+\sum_{i=0,1,...,∞}Q^i$

- The b~ij~ entries of matrix $B=N∗R$ are the probabilities that a MC started in state s~i~ will eventually be absorbed in state s~j~. 

- The probability of visiting the transient state *j* when starting from the transient state *i* is the h~ij~ entry of the
matrix $H = (N − I_t) ∗ N_{bj}^{−1}$, being *dg* the diagonal operator.


## 1.2 J.S. Bach

As I write this part, I'm listening to the magnificent B Minor Mass by J.S. Bach, a showcase of musical excellence, that I recommend the reader to listen. 

First, why Bach? J.S.Bach is know as the most prolific and ingenious composers of all time. He was a master of counterpoint, where there are lots of independent musical lines playing at the same time, forming a complex and engaging texture. He explored every major style, form and musical genre of its time. 

He completed over a 1000 compositions! He composed hundreds of chorales for organ, and many Toccatas, Fantasias, Preludes and Fugues. For keyboard he wrote many works that demonstrate the possibility of playing in every single key, which was unusual at the time. He also worked on chamber music and solo pieces, where he developed a technique that suggest harmony, so that it does not need to be accompanied by another instrument. He also wrote some dramatic orchestral and vocal pieces. My favourite works from him are from this category, namely St. John's Passion and the magnificent Mass in B Minor. 

Bach's music combined the artistic, emotional and intellectual characteristics. The Baroque era was characterized by movement, contrast, drama, detail and surprise. Although very rich, it constitutes a great starting point for applying MC, since it is more complex than modern pop music (more nodes) but not too crazy on the harmonic part as the following eras (too many nodes). It is an example of beauty in complexity. 

## 1.3 Some jump start music theory

Why focus on harmony? 

Checking the harmonic progressions is a good starting point of any musical analysis. The focus on harmonic progressions reduces the complexity associated with such a difficult and rich language as music. The melody would be a wrong choice to start, since a good melody has range, character, movement, rhythm and expressiveness. Nobody ears single notes, we ear phrases, entire lines of notes that blend to tell something. This is why it would be difficult to analyse melody.

No, some key notions before we proceed to the harmonic analysis:

- Music is not a stochastic process, although it has elements of it. Harmonic progressions need to surprise but they have an internal logic.
![](iu.png)

- Each chord (from the I~th~ to the VII~th~) as a specific function (creates a specific tension/release when combined with others)

- They don't jump randomly, it would not sound pleasing. They have different levels of attraction to other states.

- Based on this, if we want to make a jump, this has to be "prepared"/"suggested" before.

And why focus on chorales for this work? 

Well, they are easier to read and analyse then Canon or Fugues...

Before we jump to the harmonic analysis using MC, I leave below an example of what I mean by harmonic analysis.

![](chorale.png)


# 2. Harmonic Analysis

Before we get into it, we need to load the required packages. 

```{r load required packages, message=FALSE}
library(markovchain)
library(readr)
library(igraph)
require(reshape2)
require(ggplot2)
```

We'll get hands on with a dataset that has the harmonic structure for some Bach's chorales.

In this section, we'll take a look at the chorale BWV 17.7 in A_M	entitled *"Nun lob, mein Seel, den Herren"*, which means *"Now praise, my soul, the Lord"*. This was chosen based on the number of chords it has. We need to load and trim the dataset.

```{r dataset, message=F, warning=F}
jsbach_chorals_harmony <- read_csv("jsbach_chorals_harmony.data", 
                                   col_names = FALSE)
BWV_17.7 = jsbach_chorals_harmony[jsbach_chorals_harmony$X1 == '000306b_',]
bwv177 = factor(BWV_17.7$X17)
head(bwv177)
```

Then we can compute the transition matrix, with the harmonic transition probabilities for this chorale. 

```{r TM1}
TM = createSequenceMatrix(bwv177, toRowProbs = TRUE); TM
```

Having the transition matrix ready, we can create the markovchain object and plot the graph, with each node being each chord.

```{r MC1}
MC = as(TM, "markovchain")
#verify that it is a markovchain object
is(MC, 'markovchain')

plot(MC, edge.arrow.size=0.45, main='BWV 17.7 Markov Chain')
```

To keep in mind, since we are in A Major: A_M (I), B (ii/II), C# (iii/III), D (IV/vii of the V), E (V), F# (vi), G# (vii).

A Major (I~th~) is strongly connected to its V~th~ (E_M) and its vi~th~ (F#m), with and important contribution from the IV~th~ (D_M). This makes sense, since these are the most common chords from the chord attraction point of view: I-IV-vi-V-I. 

Now we can define an initial state, beginning in A_M, and check after 2 transitions:

```{r 2transitions}
#initial state
initial_state = c(0,1,0,0,0,0,0,0,0,0,0)
#2 transitions after
after_2_transitions = initial_state * (MC^2); after_2_transitions
```

Lets check the number of states in our MC and its dimension.

```{r properties1}
#states
states(MC)
#dimension
dim(MC)
```

Now lets check the transition probabilities. An aesthetically pleasing (and usual) transition I-V will probably occur, but we should not see an ugly one (id-IV) in Bach (unless he was hallucinating while writing this one).

```{r transition probabilities}
#beautiful transition, probably it will occur
transitionProbability(MC, 'A_M', 'E_M')
#ugly transition, probably it will not occur 
transitionProbability(MC, 'A#d', 'E_M')
```

Ok, we've just checked that Bach was not crazy (probably).  
Now we can try and create a coral with 10, beginning in A_M (t~0~).

```{r criar um coral}
#create a coral with 10 harmonic transitions
markovchainSequence(10, MC, t0="A_M")
```

...So, it could be better, but surely Bach could make this sequence sound nice. 

```{r steadystates1, message=FALSE}
#probability with DTMC: stationary distribution
## when the TM is irreducibile
df_MC = melt(data.frame(steadyStates(MC)))
ggplot(df_MC, aes(variable,value), ylim(c(0,0.3))) + geom_point(color='blue') + geom_text(aes(label=round(value, 4)), size=3, vjust=-2)

```

Next we will check the MC for transient states, absorbing states, recurrent and communicating classes. We can also check if F#m is accessible from E_M7.

```{r classifying states}
#classifying states
transientStates(MC)
absorbingStates(MC)
#identifying recurrent and transient classes
recurrentClasses(MC)
communicatingClasses(MC)
is.accessible(MC, from = "E_M7",to="F#m")
summary(MC)
period(MC)

#converting to igraph
MC.igraph = as(MC,"igraph")
#finding and formatting the clusters
SCC = clusters(MC.igraph, mode="strong") 
V(MC.igraph)$color = rainbow(SCC$no)[SCC$membership]
#plotting
plot(MC.igraph, mark.groups = split(1:vcount(MC.igraph), SCC$membership), main="Communicating classes - strongly connected components")
```

This MC is irreducible with only one recurrent class and no transient classes. It also doesn't have any transient or absorbing states. This is pretty typical in music, since every transition is *nudged* (or prepared) before it occurs and, although we can modulate to other tonalities, most of the time we will keep some type of linkage between the tonalities that make it possible to reach any previous state (chord).
Since $\sum_{n=1}^{∞}2n\frac{\frac{1}{2n-1}{\binom{2n}{n}}}{2^{2n}} = 1$ the probability of first return in finite time is 1, so this is recurrent.

```{r first passage}
#first passage time
firstPassage(MC,state = "A_M",5)
```

The output of this function shows that the probability of the first hit of state "E_M" occurring at the first step is 0.18 and at second step is 0.12.

In the next section we will pick the BWV 40.8 (originally in F minor but in E minor on this dataset) entitled *Freuet euch, ihr Christen alle*, which means *Rejoice, all you Christians*, and it is meant to be played in the 2nd day of Christmas. 
For this exercise, suppose that Bach hit his head before finishing this chorale. As a result, he added some (I'm pretty sure) nonsense chords that conferred a horrendous ending to this piece, as follows: 


```{r 2nd chorale}

bwv2 = jsbach_chorals_harmony[jsbach_chorals_harmony$X1 == '000408b_',]
bwv2 = bwv2$X17
bwv2 = factor(append(bwv2, c('E_m','C_M', 'A_m', 'D_M', 'G_m', 'Eb_M', 'C_m', 'Eb_M', 'G_m', 'G#_M', 'G#_M')))

TM2 = createSequenceMatrix(bwv2, toRowProbs = TRUE)
MC2 = as(TM2, 'markovchain')
summary(MC2)
```

This time, the MC is not irreducible. We have an absorbing state G#_M (one that was added), that is both a closed and recurrent class. Now we have two transient classes, one from the original piece (the strongly connected part), and the one that was added.
We can see this more clearly in the graph:

```{r graph, echo=F}
#converting to igraph
MC2.igraph = as(MC2,"igraph")
#finding and formatting the clusters
SCC = clusters(MC2.igraph, mode="strong") 
V(MC2.igraph)$color = rainbow(SCC$no)[SCC$membership]
#plotting
plot(MC2.igraph, mark.groups = split(1:vcount(MC2.igraph), SCC$membership), main="Communicating classes - strongly connected components")
```

Now that we saw the effect of the addition in the graph, next we compute the Q, R and I matrices, plus the fundamental matrix.

```{r Q R I N, message=F}
#The following function returns the Q, R, and I matrices
extractMatrices = function(mcObj) {
require(matlab)
mcObj = canonicForm(object = mcObj)
  #get the indices of transient and absorbing
transIdx = which(states(mcObj) %in% transientStates(mcObj)) #transient indexes
absIdx = which(states(mcObj) %in% absorbingStates(mcObj)) #absorbing indexes
  #get the Q, R and I matrices
Q = as.matrix(mcObj@transitionMatrix[transIdx,transIdx]) 
R = as.matrix(mcObj@transitionMatrix[transIdx,absIdx])
I = as.matrix(mcObj@transitionMatrix[absIdx, absIdx])
#get the fundamental matrix
N = solve(eye(size(Q)) - Q)
#computing final absortion probabilities 
NR = N %*% R
#return
out = list(
    canonicalForm = mcObj,
    Q = Q,
    R = R,
    I = I,
    N = N,
    NR = NR)
  return(out)
}

#decompose the matrix
MC2_dec = extractMatrices(mcObj = MC2)

#showing the fundamental matrix
MC2_fund = MC2_dec$N; MC2_fund
```

The calculated fundamental matrix shows that the number of times the chain is in state G_m, starting from state A_m is two.

```{r}
#expected number of steps before being absorbed 
MC2_fund%*%rep(1,17)
```

Also, the N ∗ 1 vector indicates that, if the chains starts in C_m, the expected number of steps before being absorbed is 9.

```{r}
#calculating B matrix
#the probability to being absorbed in G#_M state as a function of the starting transient state
MC2_B = MC2_fund%*%MC2_dec$R; MC2_B
```

Since there is only one absorbing state, G#_M, the probability to be absorbed in G#_M is one, whichever the starting transient state is.

```{r}
#calculating H, probability of visiting transient state j starting in transient state i
MC2_H = (MC2_fund - matlab::eye(ncol(MC2_fund))) * solve(diag(diag(MC2_fund))); MC2_H
```

Also, matrix H shows that the probability that a chain in state E_m will eventually visit again state E_m is 0.96.

It is not irreducible,
```{r}
period(MC2)
```

and since we have an absorbing state:

```{r}


steadyStates(MC2)
```

The relevance of the chords in the transient classes is completely lost. To have a clear picture of the long term behaviour of our process, we can correct it by introducing a damping factor 0 < α < 1. 
Given the transition matrix **TM2** for a network with *n* nodes, the Google's surfer matrix **G** is given by:

$G = α*TM2+(1-α)*R$

with R being the matrix with all entries equal to 1/n.

```{r, message=F}
#create R matrix
R = ifelse(TM2<1000,1/dim(MC2))
#apply damping factor
dampened = 0.85*TM2+(1-0.85)*R
dampened = as(dampened, 'markovchain')
df_damp = data.frame(steadyStates(dampened))
df_damp = melt(df_damp)
df_damp$SS = c('dampened')

#stationary distribution
steadyStates(dampened)

#without modification
bwv2_wo = jsbach_chorals_harmony[jsbach_chorals_harmony$X1 == '000408b_',]
bwv2_wo = bwv2_wo$X17
TM2_wo = createSequenceMatrix(bwv2_wo, toRowProbs = TRUE)
MC2_wo = as(TM2_wo, 'markovchain')
original_df = melt(data.frame(steadyStates(MC2_wo)))
original_df$SS = c('original')

#bind the two
df_all = rbind(original_df, df_damp)

#plot
ggplot(df_all, aes(variable,value, color=SS), ylim(c(0,0.15))) + geom_point()

```

This way, we can recover the information regarding the relevance of the nodes in the original chorale, which was completely lost when Bach hit is head and added the obscure harmonization in the end of this piece.

# 3. Conclusion

![](iu.jpeg)

# 4. References

Howard M.Taylor, Samuel Karlin; An Introduction to Stochastic Modelling. 3rd Edition.
The markovchain Package: A Package for Easily Handling Discrete Markov Chains in R. G.A. Spedicato, T.S. Kang, S.B. Yalamanchi, D. Yadav, I. Cordón. 
